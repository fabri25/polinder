{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport * as util from '../util';\n/**\n * Wraps a list of ArrayBuffers into a `slice()`-able object without allocating\n * a large ArrayBuffer.\n *\n * Allocating large ArrayBuffers (~2GB) can be unstable on Chrome. TFJS loads\n * its weights as a list of (usually) 4MB ArrayBuffers and then slices the\n * weight tensors out of them. For small models, it's safe to concatenate all\n * the weight buffers into a single ArrayBuffer and then slice the weight\n * tensors out of it, but for large models, a different approach is needed.\n */\nexport class CompositeArrayBuffer {\n  /**\n   * Concatenate a number of ArrayBuffers into one.\n   *\n   * @param buffers An array of ArrayBuffers to concatenate, or a single\n   *     ArrayBuffer.\n   * @returns Result of concatenating `buffers` in order.\n   */\n  static join(buffers) {\n    return new CompositeArrayBuffer(buffers).slice();\n  }\n  constructor(buffers) {\n    this.shards = [];\n    this.previousShardIndex = 0;\n    if (buffers == null) {\n      return;\n    }\n    // Normalize the `buffers` input to be `ArrayBuffer[]`.\n    if (!(buffers instanceof Array)) {\n      buffers = [buffers];\n    }\n    buffers = buffers.map(bufferOrTypedArray => {\n      if (util.isTypedArray(bufferOrTypedArray)) {\n        return bufferOrTypedArray.buffer;\n      }\n      return bufferOrTypedArray;\n    });\n    // Skip setting up shards if there are no buffers.\n    if (buffers.length === 0) {\n      return;\n    }\n    this.bufferUniformSize = buffers[0].byteLength;\n    let start = 0;\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      // Check that all buffers except the last one have the same length.\n      if (i !== buffers.length - 1 && buffer.byteLength !== this.bufferUniformSize) {\n        // Unset the buffer uniform size, since the buffer sizes are not\n        // uniform.\n        this.bufferUniformSize = undefined;\n      }\n      // Create the shards, including their start and end points.\n      const end = start + buffer.byteLength;\n      this.shards.push({\n        buffer,\n        start,\n        end\n      });\n      start = end;\n    }\n    // Set the byteLenghth\n    if (this.shards.length === 0) {\n      this.byteLength = 0;\n    }\n    this.byteLength = this.shards[this.shards.length - 1].end;\n  }\n  slice(start = 0, end = this.byteLength) {\n    // If there are no shards, then the CompositeArrayBuffer was initialized\n    // with no data.\n    if (this.shards.length === 0) {\n      return new ArrayBuffer(0);\n    }\n    // NaN is treated as zero for slicing. This matches ArrayBuffer's behavior.\n    start = isNaN(Number(start)) ? 0 : start;\n    end = isNaN(Number(end)) ? 0 : end;\n    // Fix the bounds to within the array.\n    start = Math.max(0, start);\n    end = Math.min(this.byteLength, end);\n    if (end <= start) {\n      return new ArrayBuffer(0);\n    }\n    const startShardIndex = this.findShardForByte(start);\n    if (startShardIndex === -1) {\n      // This should not happen since the start and end indices are always\n      // within 0 and the composite array's length.\n      throw new Error(`Could not find start shard for byte ${start}`);\n    }\n    const size = end - start;\n    const outputBuffer = new ArrayBuffer(size);\n    const outputArray = new Uint8Array(outputBuffer);\n    let sliced = 0;\n    for (let i = startShardIndex; i < this.shards.length; i++) {\n      const shard = this.shards[i];\n      const globalStart = start + sliced;\n      const localStart = globalStart - shard.start;\n      const outputStart = sliced;\n      const globalEnd = Math.min(end, shard.end);\n      const localEnd = globalEnd - shard.start;\n      const outputSlice = new Uint8Array(shard.buffer, localStart, localEnd - localStart);\n      outputArray.set(outputSlice, outputStart);\n      sliced += outputSlice.length;\n      if (end < shard.end) {\n        break;\n      }\n    }\n    return outputBuffer;\n  }\n  /**\n   * Get the index of the shard that contains the byte at `byteIndex`.\n   */\n  findShardForByte(byteIndex) {\n    if (this.shards.length === 0 || byteIndex < 0 || byteIndex >= this.byteLength) {\n      return -1;\n    }\n    // If the buffers have a uniform size, compute the shard directly.\n    if (this.bufferUniformSize != null) {\n      this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);\n      return this.previousShardIndex;\n    }\n    // If the buffers don't have a uniform size, we need to search for the\n    // shard. That means we need a function to check where the byteIndex lies\n    // relative to a given shard.\n    function check(shard) {\n      if (byteIndex < shard.start) {\n        return -1;\n      }\n      if (byteIndex >= shard.end) {\n        return 1;\n      }\n      return 0;\n    }\n    // For efficiency, try the previous shard first.\n    if (check(this.shards[this.previousShardIndex]) === 0) {\n      return this.previousShardIndex;\n    }\n    // Otherwise, use a generic search function.\n    // This should almost never end up being used in practice since the weight\n    // entries should always be in order.\n    const index = search(this.shards, check);\n    if (index === -1) {\n      return -1;\n    }\n    this.previousShardIndex = index;\n    return this.previousShardIndex;\n  }\n}\n/**\n * Search for an element of a sorted array.\n *\n * @param sortedArray The sorted array to search\n * @param compare A function to compare the current value against the searched\n *     value. Return 0 on a match, negative if the searched value is less than\n *     the value passed to the function, and positive if the searched value is\n *     greater than the value passed to the function.\n * @returns The index of the element, or -1 if it's not in the array.\n */\nexport function search(sortedArray, compare) {\n  // Binary search\n  let min = 0;\n  let max = sortedArray.length;\n  while (min <= max) {\n    const middle = Math.floor((max - min) / 2) + min;\n    const side = compare(sortedArray[middle]);\n    if (side === 0) {\n      return middle;\n    } else if (side < 0) {\n      max = middle;\n    } else {\n      min = middle + 1;\n    }\n  }\n  return -1;\n}","map":{"version":3,"mappings":"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","names":["util","CompositeArrayBuffer","join","buffers","slice","constructor","Array","map","bufferOrTypedArray","isTypedArray","buffer","length","bufferUniformSize","byteLength","start","i","undefined","end","shards","push","ArrayBuffer","isNaN","Number","Math","max","min","startShardIndex","findShardForByte","Error","size","outputBuffer","outputArray","Uint8Array","sliced","shard","globalStart","localStart","outputStart","globalEnd","localEnd","outputSlice","set","byteIndex","previousShardIndex","floor","check","index","search","sortedArray","compare","middle","side"],"sourceRoot":"","sources":["../../../../../../tfjs-core/src/io/composite_array_buffer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {TypedArray} from '../types';\nimport * as util from '../util';\n\ntype BufferShard = {\n  start: number,\n  end: number,\n  buffer: ArrayBuffer,\n};\n\n/**\n * Wraps a list of ArrayBuffers into a `slice()`-able object without allocating\n * a large ArrayBuffer.\n *\n * Allocating large ArrayBuffers (~2GB) can be unstable on Chrome. TFJS loads\n * its weights as a list of (usually) 4MB ArrayBuffers and then slices the\n * weight tensors out of them. For small models, it's safe to concatenate all\n * the weight buffers into a single ArrayBuffer and then slice the weight\n * tensors out of it, but for large models, a different approach is needed.\n */\n\nexport class CompositeArrayBuffer {\n  private shards: BufferShard[] = [];\n  private previousShardIndex = 0;\n  private bufferUniformSize?: number;\n  public readonly byteLength: number;\n\n  /**\n   * Concatenate a number of ArrayBuffers into one.\n   *\n   * @param buffers An array of ArrayBuffers to concatenate, or a single\n   *     ArrayBuffer.\n   * @returns Result of concatenating `buffers` in order.\n   */\n  static join(buffers?: ArrayBuffer[] | ArrayBuffer) {\n    return new CompositeArrayBuffer(buffers).slice();\n  }\n\n  constructor(buffers?: ArrayBuffer | ArrayBuffer[] | TypedArray |\n    TypedArray[]) {\n    if (buffers == null) {\n      return;\n    }\n    // Normalize the `buffers` input to be `ArrayBuffer[]`.\n    if (!(buffers instanceof Array)) {\n      buffers = [buffers];\n    }\n    buffers = buffers.map((bufferOrTypedArray) => {\n      if (util.isTypedArray(bufferOrTypedArray)) {\n        return bufferOrTypedArray.buffer;\n      }\n      return bufferOrTypedArray;\n    });\n\n    // Skip setting up shards if there are no buffers.\n    if (buffers.length === 0) {\n      return;\n    }\n\n    this.bufferUniformSize = buffers[0].byteLength;\n    let start = 0;\n\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      // Check that all buffers except the last one have the same length.\n      if (i !== buffers.length - 1 &&\n        buffer.byteLength !== this.bufferUniformSize) {\n        // Unset the buffer uniform size, since the buffer sizes are not\n        // uniform.\n        this.bufferUniformSize = undefined;\n      }\n\n      // Create the shards, including their start and end points.\n      const end = start + buffer.byteLength;\n      this.shards.push({ buffer, start, end });\n      start = end;\n    }\n\n    // Set the byteLenghth\n    if (this.shards.length === 0) {\n      this.byteLength = 0;\n    }\n    this.byteLength = this.shards[this.shards.length - 1].end;\n  }\n\n  slice(start = 0, end = this.byteLength): ArrayBuffer {\n    // If there are no shards, then the CompositeArrayBuffer was initialized\n    // with no data.\n    if (this.shards.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    // NaN is treated as zero for slicing. This matches ArrayBuffer's behavior.\n    start = isNaN(Number(start)) ? 0 : start;\n    end = isNaN(Number(end)) ? 0 : end;\n\n    // Fix the bounds to within the array.\n    start = Math.max(0, start);\n    end = Math.min(this.byteLength, end);\n    if (end <= start) {\n      return new ArrayBuffer(0);\n    }\n\n    const startShardIndex = this.findShardForByte(start);\n    if (startShardIndex === -1) {\n      // This should not happen since the start and end indices are always\n      // within 0 and the composite array's length.\n      throw new Error(`Could not find start shard for byte ${start}`);\n    }\n\n    const size = end - start;\n    const outputBuffer = new ArrayBuffer(size);\n    const outputArray = new Uint8Array(outputBuffer);\n    let sliced = 0;\n    for (let i = startShardIndex; i < this.shards.length; i++) {\n      const shard = this.shards[i];\n\n      const globalStart = start + sliced;\n      const localStart = globalStart - shard.start;\n      const outputStart = sliced;\n\n      const globalEnd = Math.min(end, shard.end);\n      const localEnd = globalEnd - shard.start;\n\n      const outputSlice = new Uint8Array(shard.buffer, localStart,\n                                         localEnd - localStart);\n      outputArray.set(outputSlice, outputStart);\n      sliced += outputSlice.length;\n\n      if (end < shard.end) {\n        break;\n      }\n    }\n    return outputBuffer;\n  }\n\n  /**\n   * Get the index of the shard that contains the byte at `byteIndex`.\n   */\n  private findShardForByte(byteIndex: number): number {\n    if (this.shards.length === 0 || byteIndex < 0 ||\n      byteIndex >= this.byteLength) {\n      return -1;\n    }\n\n    // If the buffers have a uniform size, compute the shard directly.\n    if (this.bufferUniformSize != null) {\n      this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);\n      return this.previousShardIndex;\n    }\n\n    // If the buffers don't have a uniform size, we need to search for the\n    // shard. That means we need a function to check where the byteIndex lies\n    // relative to a given shard.\n    function check(shard: BufferShard) {\n      if (byteIndex < shard.start) {\n        return -1;\n      }\n      if (byteIndex >= shard.end) {\n        return 1;\n      }\n      return 0;\n    }\n\n    // For efficiency, try the previous shard first.\n    if (check(this.shards[this.previousShardIndex]) === 0) {\n      return this.previousShardIndex;\n    }\n\n    // Otherwise, use a generic search function.\n    // This should almost never end up being used in practice since the weight\n    // entries should always be in order.\n    const index = search(this.shards, check);\n    if (index === -1) {\n      return -1;\n    }\n\n    this.previousShardIndex = index;\n    return this.previousShardIndex;\n  }\n}\n\n/**\n * Search for an element of a sorted array.\n *\n * @param sortedArray The sorted array to search\n * @param compare A function to compare the current value against the searched\n *     value. Return 0 on a match, negative if the searched value is less than\n *     the value passed to the function, and positive if the searched value is\n *     greater than the value passed to the function.\n * @returns The index of the element, or -1 if it's not in the array.\n */\nexport function search<T>(sortedArray: T[], compare: (t: T) => number): number {\n  // Binary search\n  let min = 0;\n  let max = sortedArray.length;\n\n  while (min <= max) {\n    const middle = Math.floor((max - min) / 2) + min;\n    const side = compare(sortedArray[middle]);\n\n    if (side === 0) {\n      return middle;\n    } else if (side < 0) {\n      max = middle;\n    } else {\n      min = middle + 1;\n    }\n  }\n  return -1;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}